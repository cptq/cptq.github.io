<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Derek Lim</title>
		<link>https://cptq.github.io/posts/</link>
		<description>Recent content in Posts on Derek Lim</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Fri, 27 Mar 2020 00:00:00 +0000</lastBuildDate>
		<atom:link href="https://cptq.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Flags Ranked by Matrix Rank</title>
			<link>https://cptq.github.io/posts/flags/</link>
			<pubDate>Fri, 27 Mar 2020 00:00:00 +0000</pubDate>
			
			<guid>https://cptq.github.io/posts/flags/</guid>
			<description>One day I was watching a lecture, and the lecturer noted that the flags of some nations, when viewed as matrices, have quite low rank, in the sense of the standard concept from linear algebra. I found this remark pretty amusing, so I set out to compute the ranks of some flags. The flag of Bolivia has rank one, since all of its columns are the same and hence any two columns are linearly dependent.</description>
			<content type="html"><![CDATA[<p>One day I was watching a lecture, and the lecturer noted that the flags of some nations, when viewed as matrices, have quite low <a href="https://en.wikipedia.org/wiki/Rank_(linear_algebra)">rank</a>, in the sense of the standard concept from linear algebra. I found this remark pretty amusing, so I set out to compute the ranks of some flags. The flag of Bolivia has rank one, since all of its columns are the same and hence any two columns are linearly dependent. The flag of Sweden has rank two; there are two types of columns: the all yellow ones and the ones with a blue top, yellow middle, and blue bottom, and these two types of columns are linearly independent. The rank of some flags cannot be computed by hand, so I collected some images of flags and wrote some scripts to compute them.</p>
<figure>
<img src="BO.svg" width=30%>
<figcaption>
Flag of Bolivia
</figcaption>
</figure>
<p><br></br></p>
<figure>
<img src="SE.svg" width=30%>
<figcaption>
Flag of Sweden
</figcaption>
</figure>
<h2 id="flag-images">Flag Images</h2>
<p>Luckily for me, there was some nice data available that worked perfectly for this task. Wikimedia hosts svg files with the flags of all sorts of territories and states under a consistent format. What I did at first was directly scrape the flags of sovereign states from some Wikipedia lists. After running some computations on these, I came across <a href="https://github.com/google/region-flags">this</a> repository of region flags by Google, which has the Wikipedia flags including some US state and Canadian province flags that I did not have. Thus, I started using these svg files instead. In total, we have 326 flags (with some duplicates due to, for example, Bouvet Island using the flag of Norway). I converted each svg to a png file to allow for the analysis of each flag as a matrix of pixels. Technically, the flag pngs are not quite matrices of pixels, as each pixel has a red, green, and blue value. We simply map these images to grayscale to analyze them—as far as I can tell, there are no overlaps in which two colors map to the same grayscale value.</p>
<h2 id="ranks-and-complexity-of-flags">Ranks and Complexity of Flags</h2>
<p>There is no doubt that the flags of low rank are simple and easy to unambiguously define. Any <span class="math inline">\(m \times n\)</span> real matrix of rank <span class="math inline">\(k\)</span> can be written as a sum of outer products <span class="math inline">\(\sum_{j=1}^k x_j y_j^T\)</span>, where <span class="math inline">\(x_j \in \mathbb{R}^m\)</span> and <span class="math inline">\(y_j \in \mathbb{R}^n\)</span>, so <span class="math inline">\(k(m+n)\)</span> real numbers specify the whole matrix. In fact, all that one has to do to describe the flags of Bolivia and Sweden is to specify a few colors and lines. However, the inverse is certainly not true—not all flags of high rank are complex. This is to be expected by basic linear algebra: any <span class="math inline">\(n \times n\)</span> diagonal matrix with nonzero diagonal is full rank yet can be fully specified by an <span class="math inline">\(n\)</span>-tuple of elements. In the same vein, the flag of the Republic of Congo is full rank due to its diagonal structure, yet it is composed of just three lines.</p>
<figure>
<img src="CG.svg" width=30%> </img>
<figcaption>
Flag of the Republic of the Congo
</figcaption>
</figure>
<p>Another measure of complexity of a flag is given by the size in bytes of the flag’s svg file. The Republic of Congo’s svg is only 416 bytes, placing it as only the 183rd largest file in our set. After doing my analysis, I found <a href="https://lascarides.github.io/fussyflags/">this blog post</a> which also ranks country flags by their svg file’s size in bytes, and funnily enough does so by using the size of Palau’s svg file as the smallest unit of measurement.</p>
<p>To compute ranks of the grayscale images, I simply use the <code>rank</code> function with default parameters in Julia’s default LinearAlgebra library. This function works by defining the rank as the number of singular values of <span class="math inline">\(A\)</span> that have magnitude greater than <span class="math inline">\(k \cdot \epsilon \cdot \sigma_1\)</span>, where <span class="math inline">\(k\)</span> is the smaller of number of rows and number of columns of <span class="math inline">\(A\)</span>, <span class="math inline">\(\epsilon\)</span> is <a href="https://en.wikipedia.org/wiki/Machine_epsilon">machine epsilon</a>, and <span class="math inline">\(\sigma_1\)</span> is the largest singular value of <span class="math inline">\(A\)</span>. Due to numerical error, the results are not perfect (e.g. we find that it computes the rank of the <span class="math inline">\(2 \times 200\)</span> matrix with all elements equal to <span class="math inline">\(\pi\)</span> as rank two), but we find that they are accurate in all low-rank examples besides Switzerland, for which the computed rank is 5 but the actual rank is 3.</p>
<figure>
<img src="CH.svg" width=30%></img>
<figcaption>
Flag of Switzerland
</figcaption>
</figure>
<p>Since flags have different aspect ratios and require different resolutions, the matrices are of different sizes, which makes a direct comparison of rank to be unfair. Thus, we instead consider the ratio between the rank and the maximum possible rank given the size of the matrix, <span class="math inline">\(\frac{\mathrm{rank}(A)}{\min(m,n)}\)</span>, which we call the <em>percent rank</em> of the <span class="math inline">\(m \times n\)</span> matrix <span class="math inline">\(A\)</span>.</p>
<p>Altogether, <span class="math inline">\(15\)</span> flags have full rank and <span class="math inline">\(43\)</span> flags have rank one. Every one of the flags with full rank has some diagonal structure extending along an entire diagonal. While some of these full rank flags are simple like the Republic of Congo’s, some of them are—in my eyes—deserving of full rank, like Bhutan’s. The distribution of percent ranks covers much of <span class="math inline">\([0,1]\)</span>, with some bias towards rank one and full rank values.</p>
<figure>
<img src="prank_distr.svg"></img>
<figcaption>
Distribution of percent rank
</figcaption>
</figure>
<p><br></br></p>
<figure>
<img src="full_rank.png"> </img>
<figcaption>
Full rank flags
</figcaption>
</figure>
<p>Looking at the flags of lowest rank, we see some interesting patterns in choices by flag designers. Each rank one flag either consists of only horizontal or only vertical lines. None of these rank one flags have more than four different colors, and none of them have more than five lines. A lot of territories fly the flag of France. There are two different types of rank two flags: a bicolored flag with a cross and a multicolored flag with one vertical line with a few horizontal lines. The rank three flags either have an outlined cross or Switzerland’s cross that does not extend to the edges of the flag.</p>
<figure>
<img src="rank_one.svg"> </img>
<figcaption>
Rank one flags (all scaled to 2:3 aspect ratio)
</figcaption>
</figure>
<p><br></p>
<figure>
<img src="rank_two.svg"> </img>
<figcaption>
Rank two flags
</figcaption>
</figure>
<p><br></p>
<figure>
<img src="rank_3.svg"> </img>
<figcaption>
Rank three flags
</figcaption>
</figure>
<p>We find that rank and percent rank have a nice, somewhat linear positive relationship. Also, filesize and percent rank have a somewhat positive relationship, but there is clearly a lot of deviation in which flags with low filesize have high percent rank. However, the flags with the largest filesizes do tend to have large ranks; the complexity of an svg file describing a low rank flag is just never that high. It is easy to imagine a pathological case in which a flag is solely composed of a massive amount of thin horizontal lines, in which case we have a rank one flag with a large filesize. For some reason, no state has used such a flag.</p>
<figure>
<img src=pathological_flag.svg> </img>
<figcaption>
An example pathological flag: a rank one flag with a 656KB svg file.
</figcaption>
</figure>
<p><br></br></p>
<figure>
<img src=rank_vs_prank.svg> </img>
<figcaption>
Rank vs. percent rank (Pearson correlation .649)
</figcaption>
</figure>
<p><br></br></p>
<figure>
<img src=fsize_vs_prank.svg> </img>
<figcaption>
Filesize vs. percent rank (Pearson correlation .317)
</figcaption>
</figure>
<p>Looking at the flags with the largest filesize, we see an assortment of flags with complex symbols and drawings.</p>
<figure>
<img src="top_svg_fsize.png"></img>
<figcaption>
Largest filesize flags
</figcaption>
</figure>
<p>Some of these large filesize flags still do not have very high rank. The flag of Pennsylvania has filesize 775,498 bytes and 62% rank, so it has the second largest filesize but merely 107th largest percent rank. While it has a detailed seal, the seal does not take up the whole flag, so it has many linearly dependent rows that are just entirely blue.</p>
<p>The case of Pennsylvania gives some nice intuition on these two flag complexity metrics, and suggests another way to measure complexity. We can measure each flag with a combination of these two metrics by taking the sum of the position (a better term would be rank or positional rank, but that would be confusing in the context of the linear rank) as measured by filesize with the position as measured by percent rank. Another way to combine the ranks would be through something like a <a href="https://en.wikipedia.org/wiki/Rank_product">rank product</a>, but the simple sum maintains integer values. Here are the most complex flags as measured by this metric.</p>
<figure>
<img src="top_pos.png"> </img>
<figcaption>
Top 12 flags by position sum
</figcaption>
</figure>
<p>These flags do not just have detailed symbols and drawings, but in fact they have large drawings that span significant portions of the flag, or at least diagonal lines that do. Pennsylvania falls to position 27 in this ranking, but other flags like North Dakota’s (position 4) have a seal in the middle with a lot of empty columns; the difference is that North Dakota’s seal takes up a larger portion of the vertical space of the flag, so there are many linearly independent rows. There are still some flags that somewhat hack this ranking. The flag of Florida (position 1) has a small seal, but it has diagonal lines that give it full rank.</p>
<h2 id="without-us-states-and-canadian-provinces">Without US States and Canadian Provinces</h2>
<p>For anyone who does not care for US State or Canadian provinces, we also compute the filesize and position sum rankings after omitting flags for these subregions. Note that no US State or Canadian province flags have low-rank, while many have large filesizes. Some regions change relative order in position sum after omitting the subregions, in part due to omission of subregions making the filesize rankings more compact. For instance, Saint Pierre and Miquelon is now position 1, even though it was behind Tristan da Cunha when subregions were included.</p>
<figure>
<img src="nosubregion_top_svg_fsize.png"> </img>
<figcaption>
Top 12 non-subregion flags by filesize
</figcaption>
</figure>
<p><br></br></p>
<figure>
<img src="nosubregion_top_pos.png"> </img>
<figcaption>
Top 12 non-subregion flags by position sum
</figcaption>
</figure>
<h2 id="thoughts">Thoughts</h2>
<p>The ranking of flag complexity by the sum of the rankings by percent rank and filesize seems pretty fair to me. I especially feel that the flag of Saint Pierre and Miquelon is deserving of the top spot, as it has neat designs that take up the whole flag. I am somewhat disappointed by the lack of variety in the designs of the flags of rank at most 3, but this is understandable given that flag designers probably did not care much for the rank of their flags. This type of computation would probably be pretty interesting for other types of flags and graphics. For example, the checkered flags used in auto racing have rank two and have a design distinct from the two types of rank two region flags.</p>
]]></content>
		</item>
		
		<item>
			<title>Endless Eigenart in 3 lines of code</title>
			<link>https://cptq.github.io/posts/eigart/</link>
			<pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
			
			<guid>https://cptq.github.io/posts/eigart/</guid>
			<description>Science is what we understand well enough to explain to a computer. Art is everything else we do. — Donald Knuth
 If we import numpy and matplotlib,
import numpy as np import matplotlib.pyplot as plt then we can generate really nice art in just 3 lines of code.
As = np.random.randn(6,6,3) vals = [val for s in np.linspace(0,1,500) for t in np.linspace(0,1-s,500) for val in np.linalg.eigvals(s*As[:,:,0] + t*As[:,:,1] + (1-s-t)*As[:,:,2])] plt.</description>
			<content type="html"><![CDATA[<blockquote>
<p>Science is what we understand well enough to explain to a computer. Art is everything else we do. — Donald Knuth</p>
</blockquote>
<p>If we import numpy and matplotlib,</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt</code></pre>
<p>then we can generate really nice art in just 3 lines of code.</p>
<pre><code>As = np.random.randn(6,6,3)
vals = [val for s in np.linspace(0,1,500) for t in np.linspace(0,1-s,500) for val in np.linalg.eigvals(s*As[:,:,0] + t*As[:,:,1] + (1-s-t)*As[:,:,2])]
plt.plot(np.real(vals), np.imag(vals), &#39;mo&#39;, alpha=.5, markeredgewidth=.1, markeredgecolor=&#39;k&#39;, markersize=1.5)</code></pre>
<p><img src="chs1.png" width=90%> </img><br />
<img src="chs2.png" width=90%> </img><br />
<img src="chs3.png" width=90%> </img><br />
<img src="chs4.png" width=90%> </img></p>
<p>Of course, this code was condensed for the novelty of having as few lines of code as possible. It is quite beautiful that essentially infinitely many (if not for the finiteness of the floating point system among other physical limitations) pretty images can be completely specified in so few lines of code. Compare this to the complexity of a Post-Impressionist oil painting, which would require data at the atomic level of every brushstroke to unambiguously store. To be fair, a better comparison would probably take into account the size of the library functions called along with the python interpreter, and it can be argued that a painting does not require atomic level information to understand or experience. Even so, the basic point still stands.</p>
<figure>
<img src="Cezanne.jpg" width=90% alt="A Cézanne, which cannot be specified in 3 lines of code."> </img>
<figcaption>
A Cézanne, which cannot be specified in 3 lines of code.
</figcaption>
</figure>
<p>Coming in at a more modest 9 lines we have code that is more flexible and easy to read:</p>
<pre><code>def eigenart(n, prec=500):
    A1 = np.random.randn(n,n)
    A2 = np.random.randn(n,n)
    A3 = np.random.randn(n,n)
    vals = []
    for s in np.linspace(0,1, prec):
        for t in np.linspace(0,1-s, prec):
            vals.extend(np.linalg.eigvals(s*A1 + t*A2 + (1-s-t)*A3))
    plt.plot(np.real(vals), np.imag(vals), &#39;mo&#39;, alpha=.5, markeredgewidth=.1, markeredgecolor=&#39;k&#39;, markersize=1.5)</code></pre>
<p>The generated art is simply the set of all complex numbers that occur as an eigenvalue of some matrix in a convex set of matrices. Let <span class="math inline">\(M_n(\mathrm{F})\)</span> denote the set of <span class="math inline">\(n \times n\)</span> matrices with entries in <span class="math inline">\(\mathbb{F}\)</span>, <span class="math inline">\(\sigma(A)\)</span> denote the set of eigenvalues of the matrix <span class="math inline">\(A\)</span>, and <span class="math inline">\(\mathrm{Co}(S)\)</span> denote the convex hull of <span class="math inline">\(S\)</span>. For a set of matrices <span class="math inline">\(S \subseteq M_n(\mathbb{C})\)</span>, we define the <em>hull spectra</em> of <span class="math inline">\(S\)</span> to be <span class="math display">\[\mathrm{HS}(S) = \{\lambda \in \sigma(A) : A \in \mathrm{Co}(S) \}\]</span> Thus, our <code>eigenart</code> function plots <span class="math inline">\(\mathrm{HS}(\{A_1, A_2, A_3\})\)</span> for three random matrices <span class="math inline">\(A_1, A_2,\)</span> and <span class="math inline">\(A_3\)</span> in <span class="math inline">\(M_n(\mathbb{R})\)</span> with entries drawn from a standard normal distribution. We can now understand certain properties of the generated art.</p>
<p>In the <code>eigenart</code> function, <span class="math inline">\(n\)</span> is the size of the matrices. Larger <span class="math inline">\(n\)</span> gives more complex hull spectra as each matrix in <span class="math inline">\(\mathrm{Co}(S)\)</span> has more eigenvalues, and they interact in more complex ways. <code>prec</code> controls the number of convex combinations of matrices whose eigenvalues are computed and plotted. It can be increased to get rid of some of the areas of low density, or decreased to allow for less expensive computation. The plotting parameter <code>alpha</code> allows transparent markers so that overlap can be seen. Also, the small black marker edges allow for a shading effect, as areas that are denser with eigenvalues appear darker.</p>
<p>The hull spectra shown above are symmetric about the real axis—the generator matrices were chosen to be real, and the non-real eigenvalues of real matrices in <span class="math inline">\(M_n(\mathbb{R})\)</span> come in conjugate pairs. If we instead take our random generators to have non-real entries as well, then the hull spectra does not have this symmetry. Also, real matrices tend to have some real eigenvalues with high probability (for instance, any <span class="math inline">\(n \times n\)</span> real matrix with <span class="math inline">\(n\)</span> an odd number has at least one real eigenvalue), so most hull spectra of real matrices contain a line segment or multiple line segments on the real line.</p>
<figure>
<img src="chs5.png" width=90% alt="Hull spectra of 3 random complex matrices in $M_4(\mathbb{C})$"> </img>
<figcaption>
Hull spectra of 3 random complex matrices in <span class="math inline">\(M_4(\mathrm{C})\)</span>
</figcaption>
</figure>
<p>Let <span class="math inline">\(A_{s, t} = s A_1 + t A_2 + (1-s-t) A_3\)</span> be a matrix in <span class="math inline">\(\mathrm{Co}(\{A_1, A_2, A_3\})\)</span>. Continuity and differentiability of the eigenvalues of a family of matrices is a technical subject, so what follows is rather hand-wavy. The entire set of eigenvalues of a matrix depends continuously on its entries. Some of the holes in the hull spectra are actual holes where there are no eigenvalues. However, some of the areas where there are holes or that are sparse with eigenvalues are actually mathematically completely solid; the choice of a finite number of matrices in the convex hull to evaluate at causes them to appear empty. These spots tend to occur near an eigenvalue of higher multiplicity, which is where non-differentiability of eigenvalues can occur. This explains sparse areas of eigenvalues near the real line, as when a non-real eigenvalue approaches the real line, its conjugate is another eigenvalue that approaches the real line. Elsewhere, the shading shows “folds” and other properties that seem to give the hull spectra depth. This can be explained by the fact that the hull spectra is a projection onto the first two coordinates of the higher dimensional surface consisting of points of the form <span class="math inline">\(\big(\Re\; \lambda(A_{s,t}), \Im\; \lambda(A_{s,t}), s, t\big)\)</span> in <span class="math inline">\(\mathbb{R}^4\)</span> (recall that the eigenvalues depend continuously on <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>).</p>
<p>The eigenvalues of a matrix are the roots of its characteristic polynomial, and any polynomial <span class="math inline">\(p\)</span> has a corresponding matrix <span class="math inline">\(C\)</span> (the companion matrix) such that the eigenvalues of <span class="math inline">\(C\)</span> are precisely the roots of <span class="math inline">\(p\)</span>. From another viewpoint, the hull spectra <span class="math inline">\(\mathrm{HS}(S)\)</span> can also be viewed as the roots of the characteristic polynomials of matrices in <span class="math inline">\(\mathrm{Co}(S)\)</span> Others have created or discovered art from the roots of polynomials before: this <a href="http://math.ucr.edu/home/baez/roots/">post</a> by John Baez and the work of Bahman Kalantari in <a href="https://www.cs.rutgers.edu/~kalantar/polynomiography/exhibitions.html">polynomiography</a> provide striking examples.</p>
<p>While hull spectra do provide amazing images, my interest in them arose from important problems in mathematics. One open problem that has been unsolved for decades is that of determining the set of complex numbers which occur as the eigenvalue of some <span class="math inline">\(n \times n\)</span> doubly stochastic matrix. Equivalently, this set is the hull spectra of the <span class="math inline">\(n \times n\)</span> permutation matrices. This article [<a href="https://arxiv.org/abs/1703.10992">1</a>] provides a good survey of this problem and similar problems; I have also published two works in this field [<a href="https://arxiv.org/abs/1909.10597">2</a>] [<a href="https://arxiv.org/abs/1908.03647">3</a>].</p>
<p>[1] Charles R. Johnson, Carlos Marijuán, Pietro Paparella, and Miriam Pisonero. “The NIEP.” Operator Theory, Operator Algebras, and Matrix Theory, pp. 199-220 (2018).</p>
<p>[2] Eric Jankowski, Charles R. Johnson, and Derek Lim. “Spectra of convex hulls of matrix groups.” Linear Algebra and its Applications (2020).</p>
<p>[3] Amit Harlev, Charles R. Johnson, and Derek Lim. “The Doubly Stochastic Single Eigenvalue Problem: A Computational Approach.” Experimental Mathematics (2020).</p>
<figure>
<img src="cDS6.png" width=90% alt="Eigenvalues of convex combinations of pairs of $6 \times 6$ permutation matrices. Only those in the upper half-plane are shown."> </img>
<figcaption>
Eigenvalues of convex combinations of pairs of <span class="math inline">\(6 \times 6\)</span> permutation matrices. Only those in the upper half-plane are shown.
</figcaption>
</figure>
]]></content>
		</item>
		
	</channel>
</rss>
